// Copyright 2023 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

// convert is a tool that imports profile data from one or more files (merging
// them) and outputs data to a single file, supporting various formats.
package main

import (
	"flag"
	"fmt"
	"github.com/cockroachdb/code-cov-utils/coverlib"
	"os"
	"strings"
)

func usage() {
	fmt.Fprintf(os.Stderr, `Converts and/or merges code coverage profiles.

Profile data is imported from one or more input files and is exported to a
single file. File format is determined by extension.

Usage: %s [options] -out <output-file> <input-profile> [<input-profile>]...
Flags:
`, os.Args[0])

	flag.PrintDefaults()

	fmt.Fprintf(os.Stderr, `
Supported input formats:
  - .out: Go cover format, as generated by go test -coverprofile
  - .lcov: LCOV format, as described in
           https://ltp.sourceforge.net/coverage/lcov/geninfo.1.php

Supported output formats:
  - .lcov: LCOV format, as described in
           https://ltp.sourceforge.net/coverage/lcov/geninfo.1.php
  - .json: Codecov custom coverage format, as described in 
           https://docs.codecov.com/docs/codecov-custom-coverage-format
`)
}

func main() {
	var outputFile string
	var trimPrefix string
	flag.StringVar(&outputFile, "out", "", "output file name; must end in .json or .lcov")
	flag.StringVar(&trimPrefix, "trim-prefix", "", "trim prefix from filenames")

	flag.Usage = usage

	flag.Parse()
	if outputFile == "" {
		fmt.Fprintf(os.Stderr, "Output file not specified.\n\n")
		usage()
		os.Exit(1)
	}
	inputFiles := flag.Args()
	if len(inputFiles) == 0 {
		fmt.Fprintf(os.Stderr, "No input files specified.\n\n")
		flag.Usage()
		os.Exit(1)
	}
	if err := convert(inputFiles, outputFile, trimPrefix); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(2)
	}
}

func convert(inputFiles []string, outputFile string, trimPrefix string) error {
	// Determine output format.
	outputFormat, err := coverlib.FormatFromFilename(outputFile)
	if err != nil {
		return err
	}

	// Import data.
	var allProfiles coverlib.Profiles
	for _, inputFile := range inputFiles {
		p, err := importFile(inputFile)
		if err != nil {
			return fmt.Errorf("error importing %q: %v", inputFile, err)
		}
		allProfiles.MergeWith(p)
	}

	if trimPrefix != "" {
		allProfiles.RenameFiles(func(filenameBefore string) string {
			return strings.TrimPrefix(filenameBefore, trimPrefix)
		})
	}

	out, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating %q: %v\n", outputFile, err)
	}
	if err := coverlib.Export(&allProfiles, outputFormat, out); err != nil {
		return fmt.Errorf("error exporting to %q: %v\n", outputFile, err)
	}
	if err := out.Close(); err != nil {
		return fmt.Errorf("error closing %q: %v\n", outputFile, err)
	}
	return nil
}

func importFile(inputFile string) (*coverlib.Profiles, error) {
	format, err := coverlib.FormatFromFilename(inputFile)
	if err != nil {
		return nil, err
	}
	in, err := os.Open(inputFile)
	if err != nil {
		return nil, err
	}
	return coverlib.Import(format, in)
}
